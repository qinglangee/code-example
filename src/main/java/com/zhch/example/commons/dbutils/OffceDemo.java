package com.zhch.example.commons.dbutils;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import javax.sql.DataSource;

import org.apache.commons.dbutils.AsyncQueryRunner;
import org.apache.commons.dbutils.DbUtils;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.ResultSetHandler;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;

/**
 * Demo from http://commons.apache.org/proper/commons-dbutils/examples.html
 * 
 * @author zhch
 *
 */
public class OffceDemo {

	DataSource dataSource = null;

	public void queryDemo() throws SQLException {

		// Create a ResultSetHandler implementation to convert the
		// first row into an Object[].
		ResultSetHandler<Object[]> h = new ResultSetHandler<Object[]>() {
			public Object[] handle(ResultSet rs) throws SQLException {
				if (!rs.next()) {
					return null;
				}

				ResultSetMetaData meta = rs.getMetaData();
				int cols = meta.getColumnCount();
				Object[] result = new Object[cols];

				for (int i = 0; i < cols; i++) {
					result[i] = rs.getObject(i + 1);
				}

				return result;
			}
		};

		// Create a QueryRunner that will use connections from
		// the given DataSource
		QueryRunner run = new QueryRunner(dataSource);

		// Execute the query and get the results back from the handler
		Object[] result = run.query("SELECT * FROM Person WHERE name=?", h, "John Doe");

	}

	/**
	 * 插入和更新
	 */
	public void insertAndUpdateDemo() {
		QueryRunner run = new QueryRunner(dataSource);
		try {
			// Execute the SQL update statement and return the number of
			// inserts that were made
			int inserts = run.update("INSERT INTO Person (name,height) VALUES (?,?)", "John Doe", 1.82);
			// The line before uses varargs and autoboxing to simplify the code

			// Now it's time to rise to the occation...
			int updates = run.update("UPDATE Person SET height=? WHERE name=?", 2.05, "John Doe");
			// So does the line above
		} catch (SQLException sqle) {
			// Handle it
		}

	}

	/**
	 * 异步执行 查询
	 */
	public void asyncExec() {

		ExecutorCompletionService<Integer> executor = new ExecutorCompletionService<Integer>(
				Executors.newCachedThreadPool());
		int corePoolSize = 2;
		int maxPoolSize = 10;
		ExecutorService service = new ThreadPoolExecutor(corePoolSize, maxPoolSize, 60L, TimeUnit.SECONDS,
				new LinkedBlockingQueue<Runnable>(), new ThreadPoolExecutor.AbortPolicy());
		AsyncQueryRunner asyncRun = new AsyncQueryRunner(dataSource, service);

		try {
			// Create a Callable for the update call
			Future<Integer> callable = asyncRun.update("UPDATE Person SET height=? WHERE name=?", 2.05, "John Doe");
			// Submit the Callable to the executor

			//			service.submit(callable);
		} catch (SQLException sqle) {
			// Handle it
		}

		// Sometime later (or in another thread)
		try {
			// Get the result of the update
			Integer updates = executor.take().get();
		} catch (InterruptedException ie) {
			// Handle it
		} catch (ExecutionException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	/**
	 * 返回一个对象
	 * 
	 * @throws SQLException
	 */
	public void useBeanHandler() throws SQLException {
		QueryRunner run = new QueryRunner(dataSource);

		// Use the BeanHandler implementation to convert the first
		// ResultSet row into a Person JavaBean.
		ResultSetHandler<Person> h = new BeanHandler<Person>(Person.class);

		// Execute the SQL statement with one replacement parameter and
		// return the results in a new Person object generated by the BeanHandler.
		Person p = run.query("SELECT * FROM Person WHERE name=?", h, "John Doe");
	}

	/**
	 * 返回对象列表
	 * 
	 * @throws SQLException
	 */
	public void useBeanListHandler() throws SQLException {
		QueryRunner run = new QueryRunner(dataSource);

		// Use the BeanListHandler implementation to convert all
		// ResultSet rows into a List of Person JavaBeans.
		ResultSetHandler<List<Person>> h = new BeanListHandler<Person>(Person.class);

		// Execute the SQL statement and return the results in a List of
		// Person objects generated by the BeanListHandler.
		List<Person> persons = run.query("SELECT * FROM Person", h);

	}

	/**
	 * 可以直接用 Connection 执行查询， 但你要负责关闭连接
	 * 
	 * @throws SQLException
	 */
	public void useConnection() throws SQLException {
		ResultSetHandler<Object[]> h = null; // Define a handler the same as above example

		// No DataSource so we must handle Connections manually
		QueryRunner run = new QueryRunner();

		Connection conn = null; // open a connection
		try {
			Object[] result = run.query(conn, "SELECT * FROM Person WHERE name=?", h, "John Doe");
			// do something with the result
		} finally {
			// Use this helper method so we don't have to check for null
			DbUtils.close(conn);
		}

	}

	public static void main(String[] args) throws SQLException {
		OffceDemo t = new OffceDemo();
		t.queryDemo();
	}
}
